{
  "meta": {
    "framework": "React",
    "version": "2025.1",
    "type": "best-practices",
    "intendedFor": [
      "MCP",
      "config-driven-analysis"
    ],
    "description": "Best practices for react generated from config",
    "generatedFrom": "config/simplified-best-practices.json",
    "autoGenerated": true
  },
  "bestPracticeRules": [
    {
      "id": "meaningful-names",
      "title": "Use Meaningful Names",
      "intent": "best-practices rule: Use descriptive names for variables, functions, and components. Avoid single letters unless in tight loop counters.",
      "scope": "project",
      "severity": "low",
      "enabled": true,
      "category": "best-practices",
      "detection": {
        "fileGlobs": [
          "package.json"
        ]
      },
      "recommendation": "Use descriptive names for variables, functions, and components. Avoid single letters unless in tight loop counters.",
      "codeExample": {
        "bad": "const x = getData(); const a = x.filter(u => u.age > 18);",
        "good": "const users = getData(); const adults = users.filter(user => user.age > 18);"
      },
      "confidence": "medium",
      "falsePositives": "high",
      "performanceImpact": "low",
      "easeOfRemediation": "high",
      "detectionExplanation": "Detects use meaningful names patterns in code to ensure compliance.",
      "remediationExplanation": "Fix this by: Use descriptive names for variables, functions, and components. Avoid single letters unless in tight loop counters.",
      "references": [],
      "relatedVulnerabilities": [],
      "detectionLimitations": "May not catch all instances in complex or obfuscated code.",
      "additionalNotes": "Keep dependencies updated and follow security best practices.",
      "examplesOfExploits": []
    },
    {
      "id": "error-handling",
      "title": "Handle Errors Gracefully",
      "intent": "best-practices rule: Catch async errors, show user-friendly messages, and avoid leaking stack traces in UI.",
      "scope": "project",
      "severity": "high",
      "enabled": true,
      "category": "best-practices",
      "detection": {
        "fileGlobs": [
          "package.json"
        ]
      },
      "recommendation": "Catch async errors, show user-friendly messages, and avoid leaking stack traces in UI.",
      "codeExample": {
        "bad": "const data = await fetchData();",
        "good": "try { const data = await fetchData(); } catch (error) { setError('Unable to load data'); reportError(error); }"
      },
      "confidence": "high",
      "falsePositives": "low",
      "performanceImpact": "low",
      "easeOfRemediation": "medium",
      "detectionExplanation": "Detects handle errors gracefully patterns in code to ensure compliance.",
      "remediationExplanation": "Fix this by: Catch async errors, show user-friendly messages, and avoid leaking stack traces in UI.",
      "references": [],
      "relatedVulnerabilities": [],
      "detectionLimitations": "May not catch all instances in complex or obfuscated code.",
      "additionalNotes": "Keep dependencies updated and follow security best practices.",
      "examplesOfExploits": []
    },
    {
      "id": "component-composition",
      "title": "Compose Small Components",
      "intent": "best-practices rule: Split large components into focused, reusable pieces. Prefer composition over deep prop drilling.",
      "scope": "project",
      "severity": "medium",
      "enabled": true,
      "category": "best-practices",
      "detection": {
        "fileGlobs": [
          "package.json"
        ]
      },
      "recommendation": "Split large components into focused, reusable pieces. Prefer composition over deep prop drilling.",
      "codeExample": {
        "bad": "// One 500-line component handling layout, data, and UI",
        "good": "// Compose with <UserHeader />, <UserContent />, <UserFooter />"
      },
      "confidence": "medium",
      "falsePositives": "medium",
      "performanceImpact": "low",
      "easeOfRemediation": "medium",
      "detectionExplanation": "Detects compose small components patterns in code to ensure compliance.",
      "remediationExplanation": "Fix this by: Split large components into focused, reusable pieces. Prefer composition over deep prop drilling.",
      "references": [],
      "relatedVulnerabilities": [],
      "detectionLimitations": "May not catch all instances in complex or obfuscated code.",
      "additionalNotes": "Keep dependencies updated and follow security best practices.",
      "examplesOfExploits": []
    },
    {
      "id": "const-vs-let",
      "title": "Prefer const/let over var",
      "intent": "best-practices rule: Use const by default, let when reassignment is required. Avoid var due to function scope and hoisting pitfalls.",
      "scope": "code",
      "severity": "low",
      "enabled": true,
      "category": "best-practices",
      "detection": {
        "patterns": [
          "var\\s+\\w+\\s*="
        ]
      },
      "recommendation": "Use const by default, let when reassignment is required. Avoid var due to function scope and hoisting pitfalls.",
      "codeExample": {
        "bad": "var count = 0;",
        "good": "const count = 0; // or let if it changes"
      },
      "confidence": "medium",
      "falsePositives": "high",
      "performanceImpact": "low",
      "easeOfRemediation": "high",
      "detectionExplanation": "Detects prefer const/let over var patterns in code to ensure compliance.",
      "remediationExplanation": "Fix this by: Use const by default, let when reassignment is required. Avoid var due to function scope and hoisting pitfalls.",
      "references": [],
      "relatedVulnerabilities": [],
      "detectionLimitations": "May not catch all instances in complex or obfuscated code.",
      "additionalNotes": "Keep dependencies updated and follow security best practices.",
      "examplesOfExploits": []
    },
    {
      "id": "avoid-prop-drilling",
      "title": "Avoid Prop Drilling",
      "intent": "best-practices rule: Use Context or state libraries when props must cross many levels. Pass only what each component needs.",
      "scope": "project",
      "severity": "medium",
      "enabled": true,
      "category": "best-practices",
      "detection": {
        "fileGlobs": [
          "package.json"
        ]
      },
      "recommendation": "Use Context or state libraries when props must cross many levels. Pass only what each component needs.",
      "codeExample": {
        "bad": "<App user={user} onThemeChange={setTheme} locale={locale} ...>",
        "good": "<UserProvider value={user}><ThemeProvider value={theme}>...</ThemeProvider></UserProvider>"
      },
      "confidence": "medium",
      "falsePositives": "medium",
      "performanceImpact": "low",
      "easeOfRemediation": "medium",
      "detectionExplanation": "Detects avoid prop drilling patterns in code to ensure compliance.",
      "remediationExplanation": "Fix this by: Use Context or state libraries when props must cross many levels. Pass only what each component needs.",
      "references": [],
      "relatedVulnerabilities": [],
      "detectionLimitations": "May not catch all instances in complex or obfuscated code.",
      "additionalNotes": "Keep dependencies updated and follow security best practices.",
      "examplesOfExploits": []
    },
    {
      "id": "testing-coverage",
      "title": "Test Critical Paths",
      "intent": "best-practices rule: Write tests for core flows, reducers, hooks, and components. Target at least 80% coverage on critical areas.",
      "scope": "project",
      "severity": "medium",
      "enabled": true,
      "category": "best-practices",
      "detection": {
        "fileGlobs": [
          "package.json"
        ]
      },
      "recommendation": "Write tests for core flows, reducers, hooks, and components. Target at least 80% coverage on critical areas.",
      "codeExample": {
        "bad": "// No tests",
        "good": "// Vitest/Jest tests for reducers, hooks, and page flows"
      },
      "confidence": "medium",
      "falsePositives": "medium",
      "performanceImpact": "low",
      "easeOfRemediation": "medium",
      "detectionExplanation": "Detects test critical paths patterns in code to ensure compliance.",
      "remediationExplanation": "Fix this by: Write tests for core flows, reducers, hooks, and components. Target at least 80% coverage on critical areas.",
      "references": [],
      "relatedVulnerabilities": [],
      "detectionLimitations": "May not catch all instances in complex or obfuscated code.",
      "additionalNotes": "Keep dependencies updated and follow security best practices.",
      "examplesOfExploits": []
    },
    {
      "id": "documentation",
      "title": "Document Intent",
      "intent": "best-practices rule: Add short comments/JSDoc for complex logic, public APIs, and tricky decisions. Keep docs close to code.",
      "scope": "project",
      "severity": "low",
      "enabled": true,
      "category": "best-practices",
      "detection": {
        "fileGlobs": [
          "package.json"
        ]
      },
      "recommendation": "Add short comments/JSDoc for complex logic, public APIs, and tricky decisions. Keep docs close to code.",
      "codeExample": {
        "bad": "function process(x, y) { return x + y; }",
        "good": "/** Adds tax to subtotal. */ function addTax(subtotal, rate) { return subtotal * (1 + rate); }"
      },
      "confidence": "medium",
      "falsePositives": "high",
      "performanceImpact": "low",
      "easeOfRemediation": "high",
      "detectionExplanation": "Detects document intent patterns in code to ensure compliance.",
      "remediationExplanation": "Fix this by: Add short comments/JSDoc for complex logic, public APIs, and tricky decisions. Keep docs close to code.",
      "references": [],
      "relatedVulnerabilities": [],
      "detectionLimitations": "May not catch all instances in complex or obfuscated code.",
      "additionalNotes": "Keep dependencies updated and follow security best practices.",
      "examplesOfExploits": []
    },
    {
      "id": "avoid-deeply-nested",
      "title": "Limit Nesting",
      "intent": "best-practices rule: Keep branching shallow (≤3 levels). Use early returns and helper functions to reduce indentation.",
      "scope": "project",
      "severity": "low",
      "enabled": true,
      "category": "best-practices",
      "detection": {
        "fileGlobs": [
          "package.json"
        ]
      },
      "recommendation": "Keep branching shallow (≤3 levels). Use early returns and helper functions to reduce indentation.",
      "codeExample": {
        "bad": "if (a) { if (b) { if (c) { doThing(); } } }",
        "good": "if (!a || !b || !c) return; doThing();"
      },
      "confidence": "medium",
      "falsePositives": "high",
      "performanceImpact": "low",
      "easeOfRemediation": "high",
      "detectionExplanation": "Detects limit nesting patterns in code to ensure compliance.",
      "remediationExplanation": "Fix this by: Keep branching shallow (≤3 levels). Use early returns and helper functions to reduce indentation.",
      "references": [],
      "relatedVulnerabilities": [],
      "detectionLimitations": "May not catch all instances in complex or obfuscated code.",
      "additionalNotes": "Keep dependencies updated and follow security best practices.",
      "examplesOfExploits": []
    },
    {
      "id": "dry-principle",
      "title": "Avoid Duplication",
      "intent": "best-practices rule: Extract repeated UI and logic into components or utilities. Share validation, formatting, and fetch helpers.",
      "scope": "project",
      "severity": "medium",
      "enabled": true,
      "category": "best-practices",
      "detection": {
        "fileGlobs": [
          "package.json"
        ]
      },
      "recommendation": "Extract repeated UI and logic into components or utilities. Share validation, formatting, and fetch helpers.",
      "codeExample": {
        "bad": "// Same email validation in multiple forms",
        "good": "// reuse validateEmail() helper"
      },
      "confidence": "medium",
      "falsePositives": "medium",
      "performanceImpact": "low",
      "easeOfRemediation": "medium",
      "detectionExplanation": "Detects avoid duplication patterns in code to ensure compliance.",
      "remediationExplanation": "Fix this by: Extract repeated UI and logic into components or utilities. Share validation, formatting, and fetch helpers.",
      "references": [],
      "relatedVulnerabilities": [],
      "detectionLimitations": "May not catch all instances in complex or obfuscated code.",
      "additionalNotes": "Keep dependencies updated and follow security best practices.",
      "examplesOfExploits": []
    },
    {
      "id": "modern-hooks",
      "title": "Prefer Functional Components with Hooks",
      "intent": "best-practices rule: Use functional components and modern hooks (useEffect/useMemo/useCallback/useReducer). Avoid legacy lifecycle methods and class state.",
      "scope": "code",
      "severity": "high",
      "enabled": true,
      "category": "best-practices",
      "detection": {
        "patterns": [
          "componentDidMount",
          "componentWillUnmount",
          "this.state"
        ]
      },
      "recommendation": "Use functional components and modern hooks (useEffect/useMemo/useCallback/useReducer). Avoid legacy lifecycle methods and class state.",
      "codeExample": {
        "bad": "class MyComponent extends React.Component { componentDidMount() {} }",
        "good": "function MyComponent() { useEffect(() => {/*...*/}, []); }"
      },
      "confidence": "high",
      "falsePositives": "low",
      "performanceImpact": "low",
      "easeOfRemediation": "medium",
      "detectionExplanation": "Detects prefer functional components with hooks patterns in code to ensure compliance.",
      "remediationExplanation": "Fix this by: Use functional components and modern hooks (useEffect/useMemo/useCallback/useReducer). Avoid legacy lifecycle methods and class state.",
      "references": [],
      "relatedVulnerabilities": [],
      "detectionLimitations": "May not catch all instances in complex or obfuscated code.",
      "additionalNotes": "Keep dependencies updated and follow security best practices.",
      "examplesOfExploits": []
    },
    {
      "id": "avoid-use-effect-data-fetching",
      "title": "Avoid useEffect for Data Fetching",
      "intent": "best-practices rule: Prefer data libraries (SWR/React Query) or loader patterns. Avoid fire-and-forget fetches in useEffect without abort/controllers.",
      "scope": "project",
      "severity": "high",
      "enabled": true,
      "category": "best-practices",
      "detection": {
        "fileGlobs": [
          "package.json"
        ]
      },
      "recommendation": "Prefer data libraries (SWR/React Query) or loader patterns. Avoid fire-and-forget fetches in useEffect without abort/controllers.",
      "codeExample": {
        "bad": "useEffect(() => { fetch('/api/users').then(setUsers); }, []);",
        "good": "const { data: users } = useSWR('/api/users', fetcher);"
      },
      "confidence": "high",
      "falsePositives": "low",
      "performanceImpact": "low",
      "easeOfRemediation": "medium",
      "detectionExplanation": "Detects avoid useeffect for data fetching patterns in code to ensure compliance.",
      "remediationExplanation": "Fix this by: Prefer data libraries (SWR/React Query) or loader patterns. Avoid fire-and-forget fetches in useEffect without abort/controllers.",
      "references": [],
      "relatedVulnerabilities": [],
      "detectionLimitations": "May not catch all instances in complex or obfuscated code.",
      "additionalNotes": "Keep dependencies updated and follow security best practices.",
      "examplesOfExploits": []
    },
    {
      "id": "handle-loading-states",
      "title": "Handle Loading and Error States",
      "intent": "best-practices rule: Always show loading/empty/error UI. Disable submit buttons while pending and surface actionable errors.",
      "scope": "project",
      "severity": "medium",
      "enabled": true,
      "category": "best-practices",
      "detection": {
        "fileGlobs": [
          "package.json"
        ]
      },
      "recommendation": "Always show loading/empty/error UI. Disable submit buttons while pending and surface actionable errors.",
      "codeExample": {
        "bad": "{data && <List data={data} />} // No loading/error handling",
        "good": "if (error) return <ErrorBanner />; if (!data) return <Spinner />; return <List data={data} />;"
      },
      "confidence": "medium",
      "falsePositives": "medium",
      "performanceImpact": "low",
      "easeOfRemediation": "medium",
      "detectionExplanation": "Detects handle loading and error states patterns in code to ensure compliance.",
      "remediationExplanation": "Fix this by: Always show loading/empty/error UI. Disable submit buttons while pending and surface actionable errors.",
      "references": [],
      "relatedVulnerabilities": [],
      "detectionLimitations": "May not catch all instances in complex or obfuscated code.",
      "additionalNotes": "Keep dependencies updated and follow security best practices.",
      "examplesOfExploits": []
    },
    {
      "id": "performance-memo",
      "title": "Memoize Expensive Components",
      "intent": "performance rule: Use React.memo/useMemo/useCallback for expensive renders or stable callbacks. Measure before optimizing.",
      "scope": "project",
      "severity": "low",
      "enabled": true,
      "category": "performance",
      "detection": {
        "fileGlobs": [
          "package.json"
        ]
      },
      "recommendation": "Use React.memo/useMemo/useCallback for expensive renders or stable callbacks. Measure before optimizing.",
      "codeExample": {
        "bad": "const UserCard = ({ user }) => <div>{user.name}</div>;",
        "good": "const UserCard = React.memo(({ user }) => <div>{user.name}</div>);"
      },
      "confidence": "medium",
      "falsePositives": "high",
      "performanceImpact": "low",
      "easeOfRemediation": "high",
      "detectionExplanation": "Detects memoize expensive components patterns in code to ensure compliance.",
      "remediationExplanation": "Fix this by: Use React.memo/useMemo/useCallback for expensive renders or stable callbacks. Measure before optimizing.",
      "references": [],
      "relatedVulnerabilities": [],
      "detectionLimitations": "May not catch all instances in complex or obfuscated code.",
      "additionalNotes": "Keep dependencies updated and follow security best practices.",
      "examplesOfExploits": []
    },
    {
      "id": "code-splitting",
      "title": "Code Split Large Features",
      "intent": "performance rule: Use React.lazy/dynamic imports for heavy, non-critical routes and admin panels to reduce initial bundle size.",
      "scope": "project",
      "severity": "medium",
      "enabled": true,
      "category": "performance",
      "detection": {
        "fileGlobs": [
          "package.json"
        ]
      },
      "recommendation": "Use React.lazy/dynamic imports for heavy, non-critical routes and admin panels to reduce initial bundle size.",
      "codeExample": {
        "bad": "import HeavyFeature from './HeavyFeature';",
        "good": "const HeavyFeature = React.lazy(() => import('./HeavyFeature'));"
      },
      "confidence": "medium",
      "falsePositives": "medium",
      "performanceImpact": "low",
      "easeOfRemediation": "medium",
      "detectionExplanation": "Detects code split large features patterns in code to ensure compliance.",
      "remediationExplanation": "Fix this by: Use React.lazy/dynamic imports for heavy, non-critical routes and admin panels to reduce initial bundle size.",
      "references": [],
      "relatedVulnerabilities": [],
      "detectionLimitations": "May not catch all instances in complex or obfuscated code.",
      "additionalNotes": "Keep dependencies updated and follow security best practices.",
      "examplesOfExploits": []
    },
    {
      "id": "lazy-loading-images",
      "title": "Lazy Load Offscreen Images",
      "intent": "performance rule: Lazy load imagery below the fold and provide intrinsic sizes to avoid layout shifts.",
      "scope": "project",
      "severity": "medium",
      "enabled": true,
      "category": "performance",
      "detection": {
        "fileGlobs": [
          "package.json"
        ]
      },
      "recommendation": "Lazy load imagery below the fold and provide intrinsic sizes to avoid layout shifts.",
      "codeExample": {
        "bad": "<img src='hero-large.jpg' />",
        "good": "<img src='hero-large.jpg' loading='lazy' width='1200' height='600' alt='...' />"
      },
      "confidence": "medium",
      "falsePositives": "medium",
      "performanceImpact": "low",
      "easeOfRemediation": "medium",
      "detectionExplanation": "Detects lazy load offscreen images patterns in code to ensure compliance.",
      "remediationExplanation": "Fix this by: Lazy load imagery below the fold and provide intrinsic sizes to avoid layout shifts.",
      "references": [],
      "relatedVulnerabilities": [],
      "detectionLimitations": "May not catch all instances in complex or obfuscated code.",
      "additionalNotes": "Keep dependencies updated and follow security best practices.",
      "examplesOfExploits": []
    },
    {
      "id": "bundle-analysis",
      "title": "Monitor Bundle Size",
      "intent": "performance rule: Track bundle size in CI. Keep initial JS lean; defer non-critical scripts.",
      "scope": "project",
      "severity": "low",
      "enabled": true,
      "category": "performance",
      "detection": {
        "fileGlobs": [
          "package.json"
        ]
      },
      "recommendation": "Track bundle size in CI. Keep initial JS lean; defer non-critical scripts.",
      "codeExample": {
        "bad": "// No size checks",
        "good": "// Run bundle analyzer in CI and gate on size budgets"
      },
      "confidence": "medium",
      "falsePositives": "high",
      "performanceImpact": "low",
      "easeOfRemediation": "high",
      "detectionExplanation": "Detects monitor bundle size patterns in code to ensure compliance.",
      "remediationExplanation": "Fix this by: Track bundle size in CI. Keep initial JS lean; defer non-critical scripts.",
      "references": [],
      "relatedVulnerabilities": [],
      "detectionLimitations": "May not catch all instances in complex or obfuscated code.",
      "additionalNotes": "Keep dependencies updated and follow security best practices.",
      "examplesOfExploits": []
    }
  ]
}