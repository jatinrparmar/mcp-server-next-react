{
  "meta": {
    "framework": "Next.js",
    "version": "2025.1",
    "type": "best-practices",
    "intendedFor": [
      "MCP",
      "config-driven-analysis"
    ],
    "description": "Best practices for next-js generated from config",
    "generatedFrom": "config/simplified-best-practices.json",
    "autoGenerated": true
  },
  "bestPracticeRules": [
    {
      "id": "use-app-router",
      "title": "Prefer App Router",
      "intent": "best-practices rule: Use the App Router (app/) for all new work. Reserve Pages Router only for legacy pages you haven't migrated yet.",
      "scope": "project",
      "severity": "medium",
      "enabled": true,
      "category": "best-practices",
      "detection": {
        "fileGlobs": [
          "package.json"
        ]
      },
      "recommendation": "Use the App Router (app/) for all new work. Reserve Pages Router only for legacy pages you haven't migrated yet.",
      "codeExample": {
        "bad": "// pages/index.tsx with getServerSideProps",
        "good": "// app/page.tsx with Server Components"
      },
      "confidence": "medium",
      "falsePositives": "medium",
      "performanceImpact": "low",
      "easeOfRemediation": "medium",
      "detectionExplanation": "Detects prefer app router patterns in code to ensure compliance.",
      "remediationExplanation": "Fix this by: Use the App Router (app/) for all new work. Reserve Pages Router only for legacy pages you haven't migrated yet.",
      "references": [],
      "relatedVulnerabilities": [],
      "detectionLimitations": "May not catch all instances in complex or obfuscated code.",
      "additionalNotes": "Keep dependencies updated and follow security best practices.",
      "examplesOfExploits": []
    },
    {
      "id": "server-components-default",
      "title": "Default to Server Components",
      "intent": "best-practices rule: Make components Server Components by default. Add 'use client' only when you need interactivity, browser APIs, or client-only hooks.",
      "scope": "project",
      "severity": "high",
      "enabled": true,
      "category": "best-practices",
      "detection": {
        "fileGlobs": [
          "package.json"
        ]
      },
      "recommendation": "Make components Server Components by default. Add 'use client' only when you need interactivity, browser APIs, or client-only hooks.",
      "codeExample": {
        "bad": "'use client'; export default function Page() { return <div>Static content</div>; }",
        "good": "export default function Page() { return <div>Static content</div>; } // Server Component"
      },
      "confidence": "high",
      "falsePositives": "low",
      "performanceImpact": "low",
      "easeOfRemediation": "medium",
      "detectionExplanation": "Detects default to server components patterns in code to ensure compliance.",
      "remediationExplanation": "Fix this by: Make components Server Components by default. Add 'use client' only when you need interactivity, browser APIs, or client-only hooks.",
      "references": [],
      "relatedVulnerabilities": [],
      "detectionLimitations": "May not catch all instances in complex or obfuscated code.",
      "additionalNotes": "Keep dependencies updated and follow security best practices.",
      "examplesOfExploits": []
    },
    {
      "id": "minimal-client-components",
      "title": "Keep Client Components Minimal",
      "intent": "performance rule: Limit 'use client' files to interactive islands. Push data fetching, heavy logic, and markup to Server Components to shrink client bundles.",
      "scope": "project",
      "severity": "high",
      "enabled": true,
      "category": "performance",
      "detection": {
        "fileGlobs": [
          "package.json"
        ]
      },
      "recommendation": "Limit 'use client' files to interactive islands. Push data fetching, heavy logic, and markup to Server Components to shrink client bundles.",
      "codeExample": {
        "bad": "'use client'; // large page mixing fetch + UI",
        "good": "// Server component fetches data; small client child handles just the interaction"
      },
      "confidence": "high",
      "falsePositives": "low",
      "performanceImpact": "low",
      "easeOfRemediation": "medium",
      "detectionExplanation": "Detects keep client components minimal patterns in code to ensure compliance.",
      "remediationExplanation": "Fix this by: Limit 'use client' files to interactive islands. Push data fetching, heavy logic, and markup to Server Components to shrink client bundles.",
      "references": [],
      "relatedVulnerabilities": [],
      "detectionLimitations": "May not catch all instances in complex or obfuscated code.",
      "additionalNotes": "Keep dependencies updated and follow security best practices.",
      "examplesOfExploits": []
    },
    {
      "id": "use-server-actions",
      "title": "Prefer Server Actions for Mutations",
      "intent": "best-practices rule: Use Server Actions for form submissions and mutations to keep logic on the server, reduce client JS, and simplify data consistency.",
      "scope": "project",
      "severity": "high",
      "enabled": true,
      "category": "best-practices",
      "detection": {
        "fileGlobs": [
          "package.json"
        ]
      },
      "recommendation": "Use Server Actions for form submissions and mutations to keep logic on the server, reduce client JS, and simplify data consistency.",
      "codeExample": {
        "bad": "'use client'; const submit = async (data) => fetch('/api/submit', { method: 'POST', body: data });",
        "good": "'use server'; export async function submit(data) { /* mutate on server */ } // <form action={submit}>...</form>"
      },
      "confidence": "high",
      "falsePositives": "low",
      "performanceImpact": "low",
      "easeOfRemediation": "medium",
      "detectionExplanation": "Detects prefer server actions for mutations patterns in code to ensure compliance.",
      "remediationExplanation": "Fix this by: Use Server Actions for form submissions and mutations to keep logic on the server, reduce client JS, and simplify data consistency.",
      "references": [],
      "relatedVulnerabilities": [],
      "detectionLimitations": "May not catch all instances in complex or obfuscated code.",
      "additionalNotes": "Keep dependencies updated and follow security best practices.",
      "examplesOfExploits": []
    },
    {
      "id": "use-revalidate-tags",
      "title": "Use Revalidation Tags and Paths",
      "intent": "performance rule: Tag cached fetches and invalidate with revalidateTag/revalidatePath after mutations. Avoid stale data by wiring mutations to revalidation.",
      "scope": "project",
      "severity": "medium",
      "enabled": true,
      "category": "performance",
      "detection": {
        "fileGlobs": [
          "package.json"
        ]
      },
      "recommendation": "Tag cached fetches and invalidate with revalidateTag/revalidatePath after mutations. Avoid stale data by wiring mutations to revalidation.",
      "codeExample": {
        "bad": "await fetch(api, { cache: 'force-cache' }); // no invalidation",
        "good": "await fetch(api, { next: { tags: ['users'] } }); await revalidateTag('users');"
      },
      "confidence": "medium",
      "falsePositives": "medium",
      "performanceImpact": "low",
      "easeOfRemediation": "medium",
      "detectionExplanation": "Detects use revalidation tags and paths patterns in code to ensure compliance.",
      "remediationExplanation": "Fix this by: Tag cached fetches and invalidate with revalidateTag/revalidatePath after mutations. Avoid stale data by wiring mutations to revalidation.",
      "references": [],
      "relatedVulnerabilities": [],
      "detectionLimitations": "May not catch all instances in complex or obfuscated code.",
      "additionalNotes": "Keep dependencies updated and follow security best practices.",
      "examplesOfExploits": []
    },
    {
      "id": "avoid-use-effect-data-fetching",
      "title": "Don't Fetch in useEffect",
      "intent": "best-practices rule: Fetch data in Server Components. For client needs, use Suspense with fetch caches or libraries like SWR/React Query instead of ad-hoc useEffect fetches.",
      "scope": "project",
      "severity": "high",
      "enabled": true,
      "category": "best-practices",
      "detection": {
        "fileGlobs": [
          "package.json"
        ]
      },
      "recommendation": "Fetch data in Server Components. For client needs, use Suspense with fetch caches or libraries like SWR/React Query instead of ad-hoc useEffect fetches.",
      "codeExample": {
        "bad": "'use client'; useEffect(() => { fetch('/api/data').then(setData); }, []);",
        "good": "// Server Component: const data = await fetch(api, { cache: 'no-store' });"
      },
      "confidence": "high",
      "falsePositives": "low",
      "performanceImpact": "low",
      "easeOfRemediation": "medium",
      "detectionExplanation": "Detects don't fetch in useeffect patterns in code to ensure compliance.",
      "remediationExplanation": "Fix this by: Fetch data in Server Components. For client needs, use Suspense with fetch caches or libraries like SWR/React Query instead of ad-hoc useEffect fetches.",
      "references": [],
      "relatedVulnerabilities": [],
      "detectionLimitations": "May not catch all instances in complex or obfuscated code.",
      "additionalNotes": "Keep dependencies updated and follow security best practices.",
      "examplesOfExploits": []
    },
    {
      "id": "cache-and-fetch-options",
      "title": "Set Fetch Cache Intentionally",
      "intent": "performance rule: Explicitly set cache/no-store/force-cache and next: { revalidate, tags } on fetch. Avoid implicit caching that causes stale data.",
      "scope": "project",
      "severity": "medium",
      "enabled": true,
      "category": "performance",
      "detection": {
        "fileGlobs": [
          "package.json"
        ]
      },
      "recommendation": "Explicitly set cache/no-store/force-cache and next: { revalidate, tags } on fetch. Avoid implicit caching that causes stale data.",
      "codeExample": {
        "bad": "await fetch(api); // default cache depends on method",
        "good": "await fetch(api, { cache: 'no-store' }); // or { next: { revalidate: 300, tags: ['posts'] } }"
      },
      "confidence": "medium",
      "falsePositives": "medium",
      "performanceImpact": "low",
      "easeOfRemediation": "medium",
      "detectionExplanation": "Detects set fetch cache intentionally patterns in code to ensure compliance.",
      "remediationExplanation": "Fix this by: Explicitly set cache/no-store/force-cache and next: { revalidate, tags } on fetch. Avoid implicit caching that causes stale data.",
      "references": [],
      "relatedVulnerabilities": [],
      "detectionLimitations": "May not catch all instances in complex or obfuscated code.",
      "additionalNotes": "Keep dependencies updated and follow security best practices.",
      "examplesOfExploits": []
    },
    {
      "id": "use-next-image",
      "title": "Use next/image",
      "intent": "performance rule: Use next/image for built-in optimization, responsive sizing, and lazy loading. Provide width/height to avoid CLS.",
      "scope": "project",
      "severity": "high",
      "enabled": true,
      "category": "performance",
      "detection": {
        "fileGlobs": [
          "package.json"
        ]
      },
      "recommendation": "Use next/image for built-in optimization, responsive sizing, and lazy loading. Provide width/height to avoid CLS.",
      "codeExample": {
        "bad": "<img src='/photo.jpg' />",
        "good": "import Image from 'next/image'; <Image src='/photo.jpg' width={800} height={600} alt='Team' />"
      },
      "confidence": "high",
      "falsePositives": "low",
      "performanceImpact": "low",
      "easeOfRemediation": "medium",
      "detectionExplanation": "Detects use next/image patterns in code to ensure compliance.",
      "remediationExplanation": "Fix this by: Use next/image for built-in optimization, responsive sizing, and lazy loading. Provide width/height to avoid CLS.",
      "references": [],
      "relatedVulnerabilities": [],
      "detectionLimitations": "May not catch all instances in complex or obfuscated code.",
      "additionalNotes": "Keep dependencies updated and follow security best practices.",
      "examplesOfExploits": []
    },
    {
      "id": "use-next-link",
      "title": "Use next/link for Nav",
      "intent": "performance rule: Use next/link for client navigation with prefetch. Avoid plain anchors for internal links.",
      "scope": "project",
      "severity": "medium",
      "enabled": true,
      "category": "performance",
      "detection": {
        "fileGlobs": [
          "package.json"
        ]
      },
      "recommendation": "Use next/link for client navigation with prefetch. Avoid plain anchors for internal links.",
      "codeExample": {
        "bad": "<a href='/about'>About</a>",
        "good": "import Link from 'next/link'; <Link href='/about'>About</Link>"
      },
      "confidence": "medium",
      "falsePositives": "medium",
      "performanceImpact": "low",
      "easeOfRemediation": "medium",
      "detectionExplanation": "Detects use next/link for nav patterns in code to ensure compliance.",
      "remediationExplanation": "Fix this by: Use next/link for client navigation with prefetch. Avoid plain anchors for internal links.",
      "references": [],
      "relatedVulnerabilities": [],
      "detectionLimitations": "May not catch all instances in complex or obfuscated code.",
      "additionalNotes": "Keep dependencies updated and follow security best practices.",
      "examplesOfExploits": []
    },
    {
      "id": "dynamic-imports",
      "title": "Code Split Non-Critical UI",
      "intent": "performance rule: Use next/dynamic for heavy widgets not needed on first paint (charts, editors, maps). Provide a lightweight loading fallback.",
      "scope": "project",
      "severity": "medium",
      "enabled": true,
      "category": "performance",
      "detection": {
        "fileGlobs": [
          "package.json"
        ]
      },
      "recommendation": "Use next/dynamic for heavy widgets not needed on first paint (charts, editors, maps). Provide a lightweight loading fallback.",
      "codeExample": {
        "bad": "import Heavy from './Heavy';",
        "good": "const Heavy = dynamic(() => import('./Heavy'), { ssr: false, loading: () => <Spinner /> });"
      },
      "confidence": "medium",
      "falsePositives": "medium",
      "performanceImpact": "low",
      "easeOfRemediation": "medium",
      "detectionExplanation": "Detects code split non-critical ui patterns in code to ensure compliance.",
      "remediationExplanation": "Fix this by: Use next/dynamic for heavy widgets not needed on first paint (charts, editors, maps). Provide a lightweight loading fallback.",
      "references": [],
      "relatedVulnerabilities": [],
      "detectionLimitations": "May not catch all instances in complex or obfuscated code.",
      "additionalNotes": "Keep dependencies updated and follow security best practices.",
      "examplesOfExploits": []
    },
    {
      "id": "metadata-api",
      "title": "Use Metadata API",
      "intent": "seo rule: Use export const metadata or generateMetadata for titles, descriptions, Open Graph, and structured data per route segment.",
      "scope": "project",
      "severity": "high",
      "enabled": true,
      "category": "seo",
      "detection": {
        "fileGlobs": [
          "package.json"
        ]
      },
      "recommendation": "Use export const metadata or generateMetadata for titles, descriptions, Open Graph, and structured data per route segment.",
      "codeExample": {
        "bad": "<Head><title>My Page</title></Head>",
        "good": "export const metadata = { title: 'My Page', description: '...' };"
      },
      "confidence": "high",
      "falsePositives": "low",
      "performanceImpact": "low",
      "easeOfRemediation": "medium",
      "detectionExplanation": "Detects use metadata api patterns in code to ensure compliance.",
      "remediationExplanation": "Fix this by: Use export const metadata or generateMetadata for titles, descriptions, Open Graph, and structured data per route segment.",
      "references": [],
      "relatedVulnerabilities": [],
      "detectionLimitations": "May not catch all instances in complex or obfuscated code.",
      "additionalNotes": "Keep dependencies updated and follow security best practices.",
      "examplesOfExploits": []
    },
    {
      "id": "loading-ui",
      "title": "Provide Loading UI",
      "intent": "best-practices rule: Add loading.tsx per segment for skeletons/spinners. Pair with Suspense boundaries for streaming.",
      "scope": "project",
      "severity": "medium",
      "enabled": true,
      "category": "best-practices",
      "detection": {
        "fileGlobs": [
          "package.json"
        ]
      },
      "recommendation": "Add loading.tsx per segment for skeletons/spinners. Pair with Suspense boundaries for streaming.",
      "codeExample": {
        "bad": "// No loading state",
        "good": "// app/dashboard/loading.tsx -> export default function Loading() { return <Spinner />; }"
      },
      "confidence": "medium",
      "falsePositives": "medium",
      "performanceImpact": "low",
      "easeOfRemediation": "medium",
      "detectionExplanation": "Detects provide loading ui patterns in code to ensure compliance.",
      "remediationExplanation": "Fix this by: Add loading.tsx per segment for skeletons/spinners. Pair with Suspense boundaries for streaming.",
      "references": [],
      "relatedVulnerabilities": [],
      "detectionLimitations": "May not catch all instances in complex or obfuscated code.",
      "additionalNotes": "Keep dependencies updated and follow security best practices.",
      "examplesOfExploits": []
    },
    {
      "id": "error-boundaries",
      "title": "Segment Error Boundaries",
      "intent": "best-practices rule: Add error.tsx per route segment to capture and recover from errors without taking down the entire app tree.",
      "scope": "project",
      "severity": "high",
      "enabled": true,
      "category": "best-practices",
      "detection": {
        "fileGlobs": [
          "package.json"
        ]
      },
      "recommendation": "Add error.tsx per route segment to capture and recover from errors without taking down the entire app tree.",
      "codeExample": {
        "bad": "// No error handling",
        "good": "// app/dashboard/error.tsx: 'use client'; export default function Error({ error, reset }) { /* ... */ }"
      },
      "confidence": "high",
      "falsePositives": "low",
      "performanceImpact": "low",
      "easeOfRemediation": "medium",
      "detectionExplanation": "Detects segment error boundaries patterns in code to ensure compliance.",
      "remediationExplanation": "Fix this by: Add error.tsx per route segment to capture and recover from errors without taking down the entire app tree.",
      "references": [],
      "relatedVulnerabilities": [],
      "detectionLimitations": "May not catch all instances in complex or obfuscated code.",
      "additionalNotes": "Keep dependencies updated and follow security best practices.",
      "examplesOfExploits": []
    },
    {
      "id": "route-handlers",
      "title": "Use Route Handlers",
      "intent": "best-practices rule: Prefer app/api/* route handlers over pages/api. Co-locate API logic with the segment and leverage Server Actions where possible.",
      "scope": "project",
      "severity": "medium",
      "enabled": true,
      "category": "best-practices",
      "detection": {
        "fileGlobs": [
          "package.json"
        ]
      },
      "recommendation": "Prefer app/api/* route handlers over pages/api. Co-locate API logic with the segment and leverage Server Actions where possible.",
      "codeExample": {
        "bad": "// pages/api/users.ts",
        "good": "// app/api/users/route.ts: export async function GET() { ... }"
      },
      "confidence": "medium",
      "falsePositives": "medium",
      "performanceImpact": "low",
      "easeOfRemediation": "medium",
      "detectionExplanation": "Detects use route handlers patterns in code to ensure compliance.",
      "remediationExplanation": "Fix this by: Prefer app/api/* route handlers over pages/api. Co-locate API logic with the segment and leverage Server Actions where possible.",
      "references": [],
      "relatedVulnerabilities": [],
      "detectionLimitations": "May not catch all instances in complex or obfuscated code.",
      "additionalNotes": "Keep dependencies updated and follow security best practices.",
      "examplesOfExploits": []
    },
    {
      "id": "streaming-suspense",
      "title": "Use Streaming with Suspense",
      "intent": "performance rule: Stream slow sections behind Suspense to improve TTFB and interactivity. Provide meaningful fallbacks.",
      "scope": "project",
      "severity": "medium",
      "enabled": true,
      "category": "performance",
      "detection": {
        "fileGlobs": [
          "package.json"
        ]
      },
      "recommendation": "Stream slow sections behind Suspense to improve TTFB and interactivity. Provide meaningful fallbacks.",
      "codeExample": {
        "bad": "const data = await slowFetch(); return <Slow data={data} />;",
        "good": "<Suspense fallback={<Loading />}><SlowSection /></Suspense>"
      },
      "confidence": "medium",
      "falsePositives": "medium",
      "performanceImpact": "low",
      "easeOfRemediation": "medium",
      "detectionExplanation": "Detects use streaming with suspense patterns in code to ensure compliance.",
      "remediationExplanation": "Fix this by: Stream slow sections behind Suspense to improve TTFB and interactivity. Provide meaningful fallbacks.",
      "references": [],
      "relatedVulnerabilities": [],
      "detectionLimitations": "May not catch all instances in complex or obfuscated code.",
      "additionalNotes": "Keep dependencies updated and follow security best practices.",
      "examplesOfExploits": []
    },
    {
      "id": "parallel-data-fetching",
      "title": "Fetch in Parallel",
      "intent": "performance rule: Use Promise.all or parallel awaits in Server Components to reduce latency. Avoid serial fetch waterfalls.",
      "scope": "project",
      "severity": "medium",
      "enabled": true,
      "category": "performance",
      "detection": {
        "fileGlobs": [
          "package.json"
        ]
      },
      "recommendation": "Use Promise.all or parallel awaits in Server Components to reduce latency. Avoid serial fetch waterfalls.",
      "codeExample": {
        "bad": "const users = await getUsers(); const posts = await getPosts();",
        "good": "const [users, posts] = await Promise.all([getUsers(), getPosts()]);"
      },
      "confidence": "medium",
      "falsePositives": "medium",
      "performanceImpact": "low",
      "easeOfRemediation": "medium",
      "detectionExplanation": "Detects fetch in parallel patterns in code to ensure compliance.",
      "remediationExplanation": "Fix this by: Use Promise.all or parallel awaits in Server Components to reduce latency. Avoid serial fetch waterfalls.",
      "references": [],
      "relatedVulnerabilities": [],
      "detectionLimitations": "May not catch all instances in complex or obfuscated code.",
      "additionalNotes": "Keep dependencies updated and follow security best practices.",
      "examplesOfExploits": []
    },
    {
      "id": "revalidate-data",
      "title": "Set Revalidation Intentionally",
      "intent": "performance rule: Choose revalidate per route or fetch. Use short windows for dynamic content; use 'force-cache' for stable assets; use 'no-store' for secrets.",
      "scope": "project",
      "severity": "medium",
      "enabled": true,
      "category": "performance",
      "detection": {
        "fileGlobs": [
          "package.json"
        ]
      },
      "recommendation": "Choose revalidate per route or fetch. Use short windows for dynamic content; use 'force-cache' for stable assets; use 'no-store' for secrets.",
      "codeExample": {
        "bad": "// No revalidation configured",
        "good": "export const revalidate = 600; // 10 minutes\nawait fetch(api, { cache: 'no-store' }); // for sensitive data"
      },
      "confidence": "medium",
      "falsePositives": "medium",
      "performanceImpact": "low",
      "easeOfRemediation": "medium",
      "detectionExplanation": "Detects set revalidation intentionally patterns in code to ensure compliance.",
      "remediationExplanation": "Fix this by: Choose revalidate per route or fetch. Use short windows for dynamic content; use 'force-cache' for stable assets; use 'no-store' for secrets.",
      "references": [],
      "relatedVulnerabilities": [],
      "detectionLimitations": "May not catch all instances in complex or obfuscated code.",
      "additionalNotes": "Keep dependencies updated and follow security best practices.",
      "examplesOfExploits": []
    },
    {
      "id": "font-optimization",
      "title": "Optimize Fonts with next/font",
      "intent": "performance rule: Use next/font for local/self-hosted fonts, control subsets/weights, and avoid layout shifts with style injection.",
      "scope": "project",
      "severity": "medium",
      "enabled": true,
      "category": "performance",
      "detection": {
        "fileGlobs": [
          "package.json"
        ]
      },
      "recommendation": "Use next/font for local/self-hosted fonts, control subsets/weights, and avoid layout shifts with style injection.",
      "codeExample": {
        "bad": "<link href='https://fonts.googleapis.com/...' />",
        "good": "import { Inter } from 'next/font/google'; const inter = Inter({ subsets: ['latin'], display: 'swap' });"
      },
      "confidence": "medium",
      "falsePositives": "medium",
      "performanceImpact": "low",
      "easeOfRemediation": "medium",
      "detectionExplanation": "Detects optimize fonts with next/font patterns in code to ensure compliance.",
      "remediationExplanation": "Fix this by: Use next/font for local/self-hosted fonts, control subsets/weights, and avoid layout shifts with style injection.",
      "references": [],
      "relatedVulnerabilities": [],
      "detectionLimitations": "May not catch all instances in complex or obfuscated code.",
      "additionalNotes": "Keep dependencies updated and follow security best practices.",
      "examplesOfExploits": []
    },
    {
      "id": "not-found-page",
      "title": "Custom Not Found per Segment",
      "intent": "best-practices rule: Add not-found.tsx where 404 UX matters (e.g., dashboard areas) to keep navigation consistent.",
      "scope": "project",
      "severity": "low",
      "enabled": true,
      "category": "best-practices",
      "detection": {
        "fileGlobs": [
          "package.json"
        ]
      },
      "recommendation": "Add not-found.tsx where 404 UX matters (e.g., dashboard areas) to keep navigation consistent.",
      "codeExample": {
        "bad": "// Rely on global 404",
        "good": "// app/(marketing)/not-found.tsx -> export default function NotFound() { return <Marketing404 />; }"
      },
      "confidence": "medium",
      "falsePositives": "high",
      "performanceImpact": "low",
      "easeOfRemediation": "high",
      "detectionExplanation": "Detects custom not found per segment patterns in code to ensure compliance.",
      "remediationExplanation": "Fix this by: Add not-found.tsx where 404 UX matters (e.g., dashboard areas) to keep navigation consistent.",
      "references": [],
      "relatedVulnerabilities": [],
      "detectionLimitations": "May not catch all instances in complex or obfuscated code.",
      "additionalNotes": "Keep dependencies updated and follow security best practices.",
      "examplesOfExploits": []
    },
    {
      "id": "middleware-performance",
      "title": "Keep Middleware Lean",
      "intent": "performance rule: Do only lightweight checks (auth, redirects, locale) in middleware. Avoid DB calls or heavy CPU. Fail closed for unauthorized requests.",
      "scope": "project",
      "severity": "medium",
      "enabled": true,
      "category": "performance",
      "detection": {
        "fileGlobs": [
          "package.json"
        ]
      },
      "recommendation": "Do only lightweight checks (auth, redirects, locale) in middleware. Avoid DB calls or heavy CPU. Fail closed for unauthorized requests.",
      "codeExample": {
        "bad": "// Heavy queries in middleware",
        "good": "// Validate token, redirect unauthenticated users"
      },
      "confidence": "medium",
      "falsePositives": "medium",
      "performanceImpact": "low",
      "easeOfRemediation": "medium",
      "detectionExplanation": "Detects keep middleware lean patterns in code to ensure compliance.",
      "remediationExplanation": "Fix this by: Do only lightweight checks (auth, redirects, locale) in middleware. Avoid DB calls or heavy CPU. Fail closed for unauthorized requests.",
      "references": [],
      "relatedVulnerabilities": [],
      "detectionLimitations": "May not catch all instances in complex or obfuscated code.",
      "additionalNotes": "Keep dependencies updated and follow security best practices.",
      "examplesOfExploits": []
    },
    {
      "id": "edge-runtime-selective",
      "title": "Use Edge Runtime Selectively",
      "intent": "performance rule: Opt into edge runtime only when latency-sensitive and compatible (no Node-only APIs). Keep edge bundles small and side-effect free.",
      "scope": "project",
      "severity": "medium",
      "enabled": true,
      "category": "performance",
      "detection": {
        "fileGlobs": [
          "package.json"
        ]
      },
      "recommendation": "Opt into edge runtime only when latency-sensitive and compatible (no Node-only APIs). Keep edge bundles small and side-effect free.",
      "codeExample": {
        "bad": "export const runtime = 'edge'; // but uses fs and sharp",
        "good": "export const runtime = 'edge'; // only fetch/cache/crypto"
      },
      "confidence": "medium",
      "falsePositives": "medium",
      "performanceImpact": "low",
      "easeOfRemediation": "medium",
      "detectionExplanation": "Detects use edge runtime selectively patterns in code to ensure compliance.",
      "remediationExplanation": "Fix this by: Opt into edge runtime only when latency-sensitive and compatible (no Node-only APIs). Keep edge bundles small and side-effect free.",
      "references": [],
      "relatedVulnerabilities": [],
      "detectionLimitations": "May not catch all instances in complex or obfuscated code.",
      "additionalNotes": "Keep dependencies updated and follow security best practices.",
      "examplesOfExploits": []
    },
    {
      "id": "static-exports",
      "title": "Use Static Export When Viable",
      "intent": "performance rule: For purely static sites, set output: 'export'. Ensure no server-only APIs are required.",
      "scope": "project",
      "severity": "low",
      "enabled": true,
      "category": "performance",
      "detection": {
        "fileGlobs": [
          "package.json"
        ]
      },
      "recommendation": "For purely static sites, set output: 'export'. Ensure no server-only APIs are required.",
      "codeExample": {
        "bad": "// Dynamic server needed for static marketing site",
        "good": "// next.config.js: module.exports = { output: 'export' }"
      },
      "confidence": "medium",
      "falsePositives": "high",
      "performanceImpact": "low",
      "easeOfRemediation": "high",
      "detectionExplanation": "Detects use static export when viable patterns in code to ensure compliance.",
      "remediationExplanation": "Fix this by: For purely static sites, set output: 'export'. Ensure no server-only APIs are required.",
      "references": [],
      "relatedVulnerabilities": [],
      "detectionLimitations": "May not catch all instances in complex or obfuscated code.",
      "additionalNotes": "Keep dependencies updated and follow security best practices.",
      "examplesOfExploits": []
    },
    {
      "id": "typescript-strict",
      "title": "Enable TS Strict",
      "intent": "best-practices rule: Keep tsconfig strict=true, noImplicitAny=true, strictNullChecks=true to catch issues at build time.",
      "scope": "project",
      "severity": "medium",
      "enabled": true,
      "category": "best-practices",
      "detection": {
        "fileGlobs": [
          "package.json"
        ]
      },
      "recommendation": "Keep tsconfig strict=true, noImplicitAny=true, strictNullChecks=true to catch issues at build time.",
      "codeExample": {
        "bad": "// tsconfig: strict disabled",
        "good": "// tsconfig: { \"strict\": true, \"noImplicitAny\": true }"
      },
      "confidence": "medium",
      "falsePositives": "medium",
      "performanceImpact": "low",
      "easeOfRemediation": "medium",
      "detectionExplanation": "Detects enable ts strict patterns in code to ensure compliance.",
      "remediationExplanation": "Fix this by: Keep tsconfig strict=true, noImplicitAny=true, strictNullChecks=true to catch issues at build time.",
      "references": [],
      "relatedVulnerabilities": [],
      "detectionLimitations": "May not catch all instances in complex or obfuscated code.",
      "additionalNotes": "Keep dependencies updated and follow security best practices.",
      "examplesOfExploits": []
    },
    {
      "id": "use-custom-hooks-instead-of-inline-functions",
      "title": "Use Custom Hooks Instead of Inline Functions",
      "intent": "best-practices rule: Define custom hooks for reusable logic instead of defining functions inline within components. This improves readability and reusability.",
      "scope": "project",
      "severity": "low",
      "enabled": true,
      "category": "best-practices",
      "detection": {
        "fileGlobs": [
          "package.json"
        ]
      },
      "recommendation": "Define custom hooks for reusable logic instead of defining functions inline within components. This improves readability and reusability.",
      "codeExample": {
        "bad": "function MyComponent() { const [count, setCount] = useState(0); const increment = () => setCount(count + 1); return <button onClick={increment}>{count}</button>; }",
        "good": "function useCounter() { const [count, setCount] = useState(0); const increment = () => setCount(count + 1); return { count, increment }; } function MyComponent() { const { count, increment } = useCounter(); return <button onClick={increment}>{count}</button>; } "
      },
      "confidence": "medium",
      "falsePositives": "high",
      "performanceImpact": "low",
      "easeOfRemediation": "high",
      "detectionExplanation": "Detects use custom hooks instead of inline functions patterns in code to ensure compliance.",
      "remediationExplanation": "Fix this by: Define custom hooks for reusable logic instead of defining functions inline within components. This improves readability and reusability.",
      "references": [],
      "relatedVulnerabilities": [],
      "detectionLimitations": "May not catch all instances in complex or obfuscated code.",
      "additionalNotes": "Keep dependencies updated and follow security best practices.",
      "examplesOfExploits": []
    },
    {
      "id": "avoid-excessive-nesting-in-components",
      "title": "Avoid Excessive Nesting in Components",
      "intent": "best-practices rule: Keep component nesting levels shallow to enhance readability and maintainability. Break down deeply nested components into smaller subcomponents.",
      "scope": "project",
      "severity": "low",
      "enabled": true,
      "category": "best-practices",
      "detection": {
        "fileGlobs": [
          "package.json"
        ]
      },
      "recommendation": "Keep component nesting levels shallow to enhance readability and maintainability. Break down deeply nested components into smaller subcomponents.",
      "codeExample": {
        "bad": "function ComplexComponent() { return <div><header><nav><ul><li><a href='#'>Link</a></li></ul></nav></header><main><section><article><p>Content</p></article></section></main></div>; }",
        "good": "function Header() { return <header><nav><ul><li><a href='#'>Link</a></li></ul></nav></header>; } function MainContent() { return <main><section><article><p>Content</p></article></section></    main>; } function ComplexComponent() { return <div><Header /><MainContent /></div>; } "
      },
      "confidence": "medium",
      "falsePositives": "high",
      "performanceImpact": "low",
      "easeOfRemediation": "high",
      "detectionExplanation": "Detects avoid excessive nesting in components patterns in code to ensure compliance.",
      "remediationExplanation": "Fix this by: Keep component nesting levels shallow to enhance readability and maintainability. Break down deeply nested components into smaller subcomponents.",
      "references": [],
      "relatedVulnerabilities": [],
      "detectionLimitations": "May not catch all instances in complex or obfuscated code.",
      "additionalNotes": "Keep dependencies updated and follow security best practices.",
      "examplesOfExploits": []
    },
    {
      "id": "use-environment-variables-for-configuration",
      "title": "Use Environment Variables for Configuration",
      "intent": "best-practices rule: Store configuration values such as API endpoints, feature flags, and environment-specific settings in environment variables instead of hardcoding them in the codebase.",
      "scope": "project",
      "severity": "medium",
      "enabled": true,
      "category": "best-practices",
      "detection": {
        "fileGlobs": [
          "package.json"
        ]
      },
      "recommendation": "Store configuration values such as API endpoints, feature flags, and environment-specific settings in environment variables instead of hardcoding them in the codebase.",
      "codeExample": {
        "bad": "const apiUrl = 'https://api.example.com/v1/';",
        "good": "const apiUrl = process.env.NEXT_PUBLIC_API_URL;"
      },
      "confidence": "medium",
      "falsePositives": "medium",
      "performanceImpact": "low",
      "easeOfRemediation": "medium",
      "detectionExplanation": "Detects use environment variables for configuration patterns in code to ensure compliance.",
      "remediationExplanation": "Fix this by: Store configuration values such as API endpoints, feature flags, and environment-specific settings in environment variables instead of hardcoding them in the codebase.",
      "references": [],
      "relatedVulnerabilities": [],
      "detectionLimitations": "May not catch all instances in complex or obfuscated code.",
      "additionalNotes": "Keep dependencies updated and follow security best practices.",
      "examplesOfExploits": []
    }
  ]
}