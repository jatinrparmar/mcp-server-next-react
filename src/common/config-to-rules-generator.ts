/**
 * CONFIG-TO-RULES GENERATOR
 * 
 * Single Source of Truth: Update config/, rules/ auto-generate
 * Developers only need to modify config/
 */

import * as fs from 'node:fs';
import * as path from 'node:path';

interface SimpleRule {
  id: string;
  title: string;
  enabled: boolean;
  severity: 'critical' | 'high' | 'medium' | 'low';
  patterns?: string[];
  excludePatterns?: string[];
  recommendation: string;
  category: string;
  codeExample?: {
    bad: string;
    good: string;
  };
}

interface RuleReference {
  owasp?: string;
  cwe?: string;
  url?: string;
}

/**
 * Convert simple rule to LLM-ready rule
 * This adds all the LLM context automatically
 */
function enrichRuleForLLM(rule: SimpleRule, references?: RuleReference[]): any {
  const severityLevels = {
    critical: { confidence: 'high', falsePositives: 'low', performanceImpact: 'low', easeOfRemediation: 'high' },
    high: { confidence: 'high', falsePositives: 'low', performanceImpact: 'low', easeOfRemediation: 'medium' },
    medium: { confidence: 'medium', falsePositives: 'medium', performanceImpact: 'low', easeOfRemediation: 'medium' },
    low: { confidence: 'medium', falsePositives: 'high', performanceImpact: 'low', easeOfRemediation: 'high' }
  };

  const metadata = severityLevels[rule.severity];

  return {
    id: rule.id,
    title: rule.title,
    intent: `${rule.category} rule: ${rule.recommendation}`,
    scope: rule.patterns ? 'code' : 'project',
    severity: rule.severity,
    enabled: rule.enabled,
    category: rule.category,
    
    // Detection
    detection: rule.patterns ? {
      patterns: rule.patterns,
      ...(rule.excludePatterns && { excludePatterns: rule.excludePatterns })
    } : { fileGlobs: ['package.json'] },

    // From config
    recommendation: rule.recommendation,
    codeExample: rule.codeExample,

    // Auto-generated for LLM
    ...metadata,
    detectionExplanation: `Detects ${rule.title.toLowerCase()} patterns in code to ensure compliance.`,
    remediationExplanation: `Fix this by: ${rule.recommendation}`,
    
    // References
    references: references?.map(r => r.url).filter(Boolean) || [],
    owasp: references?.find(r => r.owasp)?.owasp,
    relatedVulnerabilities: references?.filter(r => r.cwe).map(r => r.cwe) || [],
    
    // LLM Context
    detectionLimitations: 'May not catch all instances in complex or obfuscated code.',
    additionalNotes: 'Keep dependencies updated and follow security best practices.',
    examplesOfExploits: []
  };
}

/**
 * Generate rules from config
 */
export class ConfigToRulesGenerator {
  /**
   * Generate security rules from config
   */
  static generateSecurityRules(config: any, framework: 'react' | 'next-js', rules: SimpleRule[]): any {
    return {
      meta: {
        framework: framework === 'next-js' ? 'Next.js' : 'React',
        version: '2025.1',
        type: 'security',
        intendedFor: ['MCP', 'config-driven-analysis'],
        description: `Security rules for ${framework} generated from config`,
        generatedFrom: 'config/simplified-security-rules.json',
        autoGenerated: true
      },
      securityRules: rules
        .filter(r => r.category.startsWith('security'))
        .map(rule => enrichRuleForLLM(rule))
    };
  }

  /**
   * Generate best practices from config
   */
  static generateBestPractices(config: any, framework: 'react' | 'next-js', rules: SimpleRule[]): any {
    return {
      meta: {
        framework: framework === 'next-js' ? 'Next.js' : 'React',
        version: '2025.1',
        type: 'best-practices',
        intendedFor: ['MCP', 'config-driven-analysis'],
        description: `Best practices for ${framework} generated from config`,
        generatedFrom: 'config/simplified-best-practices.json',
        autoGenerated: true
      },
      bestPracticeRules: rules
        .filter(r => r.category === 'best-practices' || r.category === 'performance' || r.category === 'seo')
        .map(rule => enrichRuleForLLM(rule))
    };
  }

  /**
   * Generate accessibility rules from config
   */
  static generateAccessibilityRules(rules: SimpleRule[]): any {
    return {
      meta: {
        framework: 'React + Next.js',
        version: '2025.1',
        type: 'accessibility',
        intendedFor: ['MCP', 'config-driven-analysis'],
        description: 'Accessibility and WCAG compliance rules',
        generatedFrom: 'config/simplified-accessibility-rules.json',
        autoGenerated: true
      },
      accessibilityRules: rules
        .filter(r => r.category === 'accessibility')
        .map(rule => enrichRuleForLLM(rule))
    };
  }

  /**
   * Generate all rules from config files
   */
  static generateAllRules(configDir: string, outputDir: string): void {
    console.log('\nðŸ”„ Generating rules from config...\n');

    // Ensure output directory exists
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }

    // Load React security rules
    try {
      const reactSecurityConfig = JSON.parse(
        fs.readFileSync(path.join(configDir, 'simplified-security-rules-react.json'), 'utf-8')
      );
      const reactSecurityRules = this.generateSecurityRules({}, 'react', reactSecurityConfig.rules);
      fs.writeFileSync(
        path.join(outputDir, 'react-llm-security-rules.json'),
        JSON.stringify(reactSecurityRules, null, 2)
      );
      console.log(`âœ“ Generated: react-llm-security-rules.json`);
    } catch (e) {
      console.log('âš  Skipping React security rules:', (e as Error).message);
    }

    // Load Next.js security rules
    try {
      const nextSecurityConfig = JSON.parse(
        fs.readFileSync(path.join(configDir, 'simplified-security-rules-nextjs.json'), 'utf-8')
      );
      const nextSecurityRules = this.generateSecurityRules({}, 'next-js', nextSecurityConfig.rules);
      fs.writeFileSync(
        path.join(outputDir, 'nextjs-llm-security-rules.json'),
        JSON.stringify(nextSecurityRules, null, 2)
      );
      console.log(`âœ“ Generated: nextjs-llm-security-rules.json`);
    } catch (e) {
      console.log('âš  Skipping Next.js security rules:', (e as Error).message);
    }

    // Load React best practices
    try {
      const reactBestPracticesConfig = JSON.parse(
        fs.readFileSync(path.join(configDir, 'simplified-best-practices-rules-react.json'), 'utf-8')
      );
      const reactBestPractices = this.generateBestPractices({}, 'react', reactBestPracticesConfig.rules);
      fs.writeFileSync(
        path.join(outputDir, 'react-llm-best-practices.json'),
        JSON.stringify(reactBestPractices, null, 2)
      );
      console.log(`âœ“ Generated: react-llm-best-practices.json`);
    } catch (e) {
      console.log('âš  Skipping React best practices:', (e as Error).message);
    }

    // Load Next.js best practices
    try {
      const nextBestPracticesConfig = JSON.parse(
        fs.readFileSync(path.join(configDir, 'simplified-best-practices-rules-nextjs.json'), 'utf-8')
      );
      const nextBestPractices = this.generateBestPractices({}, 'next-js', nextBestPracticesConfig.rules);
      fs.writeFileSync(
        path.join(outputDir, 'nextjs-llm-best-practices.json'),
        JSON.stringify(nextBestPractices, null, 2)
      );
      console.log(`âœ“ Generated: nextjs-llm-best-practices.json`);
    } catch (e) {
      console.log('âš  Skipping Next.js best practices:', (e as Error).message);
    }

    // Load accessibility rules
    try {
      const a11yConfig = JSON.parse(
        fs.readFileSync(path.join(configDir, 'simplified-accessibility-rules.json'), 'utf-8')
      );
      const a11yRules = this.generateAccessibilityRules(a11yConfig.rules);
      fs.writeFileSync(
        path.join(outputDir, 'react-next-llm-accessibility-rules.json'),
        JSON.stringify(a11yRules, null, 2)
      );
      console.log(`âœ“ Generated: react-next-llm-accessibility-rules.json`);
    } catch (e) {
      console.log('âš  Skipping accessibility rules:', (e as Error).message);
    }

    console.log('\nâœ… Rules generation complete!\n');
  }
}

// Run generator if executed directly
if (import.meta.url === `file://${process.argv[1]}`) {
  const configDir = process.argv[2] || './src/config';
  const outputDir = process.argv[3] || './src/rules';
  ConfigToRulesGenerator.generateAllRules(configDir, outputDir);
}

export default ConfigToRulesGenerator;
